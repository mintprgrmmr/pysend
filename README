## О проекте
Простая реализация клиента и сервера на Python для передачи файла по UDP.  
Сервер ждет имя файла от клиента, читает его локально и отправляет содержимое частями.
Клиент отправляет запрос от имени файла и сохраняет полученные данные в локальную директорию.

## Реализация
- UDP клиент и сервер для передачи файлов.
- Bash-скрипт для генерации тестовых данных и проверки результата.
- Обработка ошибок (OSError, ConnectionRefusedError, FileNotFoundError), type hints (mypy).
- Логирование шагов работы с единообразными сообщениями.
- Файлы клиента и сервера разделены по папкам (`src/` для кода, `test/` для тестовых файлов).

## Запуск
1. Создать и активировать виртуальное окружение (по желанию):
   ```bash
   python3 -m venv venv
   source venv/bin/activate
2. Запустить тестовый скрипт:
    ```bash
    ./test/e2e.sh
    ```
Скрипт:
- создаст каталоги test/data/source и test/data/saved;
- сгенерирует бинарный файл source.bin (2 MB случайных байт);
- запустит сервер и клиента;
- сравнит исходный и полученный файлы через `cmp`.

Если всё успешно: [TEST]FAIL: файлы различаются.*

*UDP не гарантирует: сохранность всех пакетов (часть может потеряться); 
порядок доставки (пакеты могут прийти не по очереди), целостность файла целиком. 
Cкрипт честно показывает ненадёжность UDP для передачи файлов.

## Последние изменения
- исправлена логика в соответствии с заданием: теперь сервер отдает файл, а клиент его сохраняет.
- добавлена проверка имени запрашиваемого файла на сервере.
- лог-сообщения приведены к формату: [SERVER][...], [CLIENT][...].

## Источники
[UDP-ССЫЛКИ] В процессе работы использовалась официальная документация и материалы для изучения:

UDP socket:
- [Python docs — UDP Communication](https://wiki.python.org/moin/UdpCommunication)
- [Python docs — socket HOWTO](https://docs.python.org/3/howto/sockets.html)
- [Python docs — Low-level networking interface](https://docs.python.org/2/library/socket.html)

*Полный список справочной информации содержится в ветке main.

---
## Ошибка протокола передачи (STOP_MARK)
1. В конкретной реализации ограничителем передачи выступает STOP_MARK. STOP_MARK сообщает клиенту, когда передача файла завершена (приходит отдельным пакетом). 
Теоретически, пакет может иметь любую длину, не более указанного SIZE, но если случайный пакет в цепочке окажется равен STOP_MARK, есть вероятность, что клиент не сможет отличить содержание пакета от ограничителя передачи, ввиду особенностей протокола, и закончит запись.
2. STOP_MARK: bytes = b"__STOP__". b"" - строка в байтах, каждая буква или символ в b-строке = 1 байт => STOP_MARK = 8 байт. Заданный
размер UDP-чанка(SIZE) = 1024 байта.
    data, _ = clientsocket.recvfrom(SIZE) 
    if data == STOP_MARK:                 
        break
    file.write(data)
Исходя из этого участка кода, каждый пришедший пакет будет сравниваться со STOP_MARK, чтобы определить конец передачи. 
Значит, пакету достаточно иметь длину 8 байт, чтобы передача завершилась. В UDP (при recvfrom) один пакет = одно отправление (sendto),  пока весь файл не будет отправлен такими кусками. 
Если пакет окажется длинее SIZE, хвост потеряется. 
3. В моей реализации это невозможно, так как сервер сам шлет пакеты не более указанного SIZE. 
Но можно создать шаблон файла, который вызовет баг (например, размером 1024 + 8, где последние байты будут равны STOP_MARK). 
В этом случае, последний кусок данных (эти самые 8 байт) попадет в recvfrom отдельным пакетом, совпадет со STOP_MARK и не будет записан. 
В результате файл на стороне клиента будет короче ровно на 8 байт, хотя сервер отправил его полностью.
4. Предпринята попытка проверки установленной гипотезы.
```
Из скрипта были убраны строчки с созданием файла, файл создан вручную с конкретным содержимым:
head -c 1024 /dev/zero > test/data/source/source.bin    
echo -n "__STOP__" >> test/data/source/source.bin       
./test/e2e.sh

Вывод скрипта:
cmp: EOF в test/data/saved/sendfile.txt после байта 1024 в строке 1
[TEST]FAIL: файлы различаются.

ls -l test/data/source/source.bin test/data/saved/sendfile.txt
-rw-r--r-- 1 maa@amicon.lan пользователи домена@amicon.lan 1024 сен  3 17:42 test/data/saved/sendfile.txt
-rw-r--r-- 1 maa@amicon.lan пользователи домена@amicon.lan 1032 сен  3 17:42 test/data/source/source.bin
```
В ходе простой проверки предположение подтвердилось. Разница между исходным файлом и полученным ровно в 8 байт.
5. Возможное решение: исключить STOP_MARK из логики совсем. Если поиск по содержимому файла вызывает возможную ошибку, необходимо другое решение. 
Еще одно уникальное свойство файла - размер. Если знать размер файла в байтах изначально, чтобы клиент понимал, сколько придется записать в сумме,  то клиент будет при чтении складывать чанки, пока не накопит полученное от сервера значение размера файла. 
Значит, необходимо сначала слать размер  файла и только после этого данные. Реализацию подобного решения удалось найти на https://stackoverflow.com/questions/57794550/sending-large-files-over-udp. 
После некоторого изучения вики выяснилось, что модули os и struct могут закрыть новую логику частично или полностью.
